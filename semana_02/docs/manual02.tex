\documentclass[11pt, a4paper]{article}

% --- MOTOR DE FUENTES (XeLaTeX) ---
\usepackage{fontspec}

% Intentamos cargar fuentes comunes en Linux.
% Si no tienes "DejaVu Sans", puedes cambiarlo por "Arial" o "FreeSans".
\setmainfont{DejaVu Sans}[
    BoldFont={DejaVu Sans Bold},
    ItalicFont={DejaVu Sans Oblique},
    Scale=0.9
]
\setmonofont{DejaVu Sans Mono}[Scale=0.8] % Fuente para c√≥digo que soporta Unicode

% --- IDIOMA ---
\usepackage{polyglossia}
\setmainlanguage{spanish}

% --- PAQUETES DE DISE√ëO Y MATEM√ÅTICAS ---
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[most]{tcolorbox}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows, positioning, babel}

% --- GEOMETR√çA ---
\geometry{top=2.5cm, bottom=2.5cm, left=2.5cm, right=4cm, marginparwidth=3cm}
\setlength{\headheight}{28pt}

% --- COLORES ---
\definecolor{primary}{RGB}{0, 85, 164}
\definecolor{accent}{RGB}{34, 139, 34}
\definecolor{danger}{RGB}{204, 0, 0}
\definecolor{codebg}{RGB}{245, 247, 250}

% --- CAJAS PERSONALIZADAS ---
\newtcolorbox{conceptbox}[1]{
  colback=blue!5!white, colframe=primary, title=#1, fonttitle=\bfseries,
  boxrule=0.5mm, arc=2mm, shadow={2mm}{-2mm}{0mm}{black!20}
}

\newtcolorbox{agrobox}[1]{
  colback=green!5!white, colframe=accent, title=#1, fonttitle=\bfseries,
  boxrule=0.5mm, arc=2mm
}

\newtcolorbox{warningbox}[1]{
  colback=red!5!white, colframe=danger, title=#1, fonttitle=\bfseries,
  boxrule=0.5mm, arc=2mm
}

% --- CONFIGURACI√ìN DE C√ìDIGO (SOLUCI√ìN A EMOJIS) ---
\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{codebg},
    commentstyle=\color{gray}\itshape,
    keywordstyle=\color{primary}\bfseries,
    numberstyle=\tiny\color{gray},
    stringstyle=\color{accent},
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    frame=l,
    rulecolor=\color{primary},
    numbers=left,
    showstringspaces=false,
    % Aqu√≠ mapeamos caracteres especiales para que no den error
    literate=
    {√°}{{\'a}}1 {√©}{{\'e}}1 {√≠}{{\'i}}1 {√≥}{{\'o}}1 {√∫}{{\'u}}1 {√±}{{\~n}}1
    {‚ö†}{{\textcolor{orange}{\bfseries !}}}1  % Reemplaza emoji por exclamaci√≥n
    {üíß}{{\textcolor{blue}{O}}}1            % Reemplaza gota por O
    {‚úÖ}{{\textcolor{green}{OK}}}1           % Reemplaza check por OK
    {‚Äî}{{--}}1                               % Guion largo
    {‚Äì}{{--}}1                               % Guion medio
}
\lstset{style=pythonstyle}

% --- ENCABEZADO ---
\pagestyle{fancy}
\fancyhf{}
\lhead{\textbf{Ingenier√≠a de Software I}}
\rhead{Semana 02: Python para IA Agroindustrial}
\rfoot{\thepage}

\title{\textbf{Python para Ciencia de Datos Agroindustrial}\\ Fundamentos Pr√°cticos para la Inteligencia Artificial}
\author{Curso de IA Aplicada al Agro}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section*{Prefacio: Python como Asistente Inteligente del Campo}

Tras dominar la terminal y Git en la Semana 1, ahora usar√°s \textbf{Python para dar inteligencia a tus datos}. Este lenguaje es la herramienta est√°ndar en IA porque es legible, flexible y tiene librer√≠as poderosas.

Al finalizar, podr√°s:
\begin{itemize}
    \item Escribir scripts que eval√∫en condiciones de cultivo.
    \item Procesar mediciones de sensores y archivos CSV.
    \item Entender por qu√© NumPy es esencial para la IA.
    \item Guardar tu trabajo en Git, como un verdadero ingeniero.
\end{itemize}

> \textbf{Recuerda}: No se trata de memorizar sintaxis, sino de resolver problemas reales del agro ‚Äî y versionar tus soluciones.

\newpage

\section{Cap√≠tulo I: Automatizar Decisiones Agron√≥micas}

La programaci√≥n es simplemente \textbf{automatizar reglas}. En agroindustria, ya usas reglas todos los d√≠as:
\textit{‚ÄúSi la humedad es baja y la temperatura alta, riego.‚Äù}
Python te permite codificar esas reglas.

\subsection{Variables: Etiquetas para tus datos}
Una variable guarda un valor. Piensa en ellas como etiquetas en frascos de laboratorio.

\begin{lstlisting}[language=Python, caption={Datos de una parcela}]
temperatura = 28.5   # en grados Celsius
humedad = 72         # en porcentaje
parcela = "Zona Norte"
activo = True        # Sensor activo
\end{lstlisting}

\subsection{Decisiones autom√°ticas: if / elif / else}
Python eval√∫a condiciones y act√∫a seg√∫n reglas.

\begin{lstlisting}[language=Python, caption={Sistema de riego autom√°tico}]
if humedad < 40:
    print("‚ö†Ô∏è Riego necesario en", parcela)
elif humedad > 80:
    print("üíß Drenaje recomendado")
else:
    print("‚úÖ Condiciones √≥ptimas")
\end{lstlisting}

\begin{agrobox}{Aplicaci√≥n en IA}
Los modelos de Machine Learning (como √°rboles de decisi√≥n) toman miles de decisiones como esta, pero aprendidas de los datos, no escritas a mano.
\end{agrobox}

\subsection{Repetici√≥n eficiente: bucles \texttt{for}}
Cuando tienes m√∫ltiples parcelas, no repites c√≥digo: usas un bucle.

\begin{lstlisting}[language=Python, caption={An√°lisis de varias parcelas}]
rendimientos = [25, 30, 28, 32]  # qq/ha

for i in range(len(rendimientos)):
    r = rendimientos[i]
    if r > 30:
        print(f"Parcela {i+1}: Alta productividad ({r} qq/ha)")
    else:
        print(f"Parcela {i+1}: Revisar manejo ({r} qq/ha)")
\end{lstlisting}

\subsection{Funciones: Empaqueta tu l√≥gica}
Una funci√≥n es una receta reutilizable.

\begin{lstlisting}[language=Python, caption={Evaluaci√≥n de suelo}]
def evaluar_suelo(ph):
    """Devuelve una recomendaci√≥n seg√∫n el pH del suelo."""
    if ph < 5.5:
        return "√Åcido ‚Äì necesita cal"
    elif ph > 7.5:
        return "Alcalino ‚Äì necesita azufre"
    else:
        return "pH √≥ptimo"

print("Recomendaci√≥n:", evaluar_suelo(6.2))
\end{lstlisting}

\newpage

\section{Cap√≠tulo II: Trabajar con Datos Reales}

En la agroindustria, los datos viven en archivos. Aprender√°s a leerlos y organizarlos.

\subsection{Listas: Series de mediciones}
Ideal para temperaturas diarias, rendimientos por parcela, etc.

\begin{lstlisting}[language=Python]
temperaturas = [22.1, 23.5, 25.0, 24.8, 26.2]
promedio = sum(temperaturas) / len(temperaturas)
print(f"Temp. promedio: {promedio:.1f} C")
\end{lstlisting}

\subsection{Diccionarios: Registros estructurados}
√ötil para representar sensores, parcelas o lotes.

\begin{lstlisting}[language=Python, caption={Sensor inteligente}]
sensor_zona1 = {
    "nombre": "Zona A",
    "temperatura": 26.3,
    "humedad": 68,
    "activo": True
}

print(f"{sensor_zona1['nombre']}: {sensor_zona1['temperatura']} C")
\end{lstlisting}

\subsection{Archivos CSV: Leer datos del mundo real}
Un archivo CSV es una tabla. Puedes leerlo l√≠nea por l√≠nea:

\begin{lstlisting}[language=Python, caption={Lectura manual de cosecha.csv}]
with open('cosecha.csv', 'r') as f:
    lineas = f.readlines()

# Saltar encabezado
for linea in lineas[1:]:
    parcela, rend, hum = linea.strip().split(',')
    print(f"{parcela}: {rend} qq/ha, humedad {hum}%")
\end{lstlisting}

\newpage

\section{Cap√≠tulo III: Hacia la Eficiencia ‚Äî Introducci√≥n a NumPy}

Cuando tus datos crecen, el c√≥digo com√∫n se vuelve lento. Aqu√≠ entra \textit{NumPy}.

\subsection{¬øPor qu√© NumPy? Un ejemplo con datos reales}
Sup√≥n que tienes un archivo \texttt{temperaturas.txt} con 365 valores.

\begin{lstlisting}[language=Python, caption={Con listas (lento)}]
temps = []
with open('temperaturas.txt') as f:
    for linea in f:
        temps.append(float(linea))

dias_calurosos = sum(1 for t in temps if t > 30)
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Con NumPy (r√°pido y limpio)}]
import numpy as np
temps = np.loadtxt('temperaturas.txt')
dias_calurosos = np.sum(temps > 30)
\end{lstlisting}

\begin{conceptbox}{¬øQu√© cambia?}
NumPy almacena los n√∫meros de forma compacta y usa operaciones optimizadas en C. Para IA, siempre usamos NumPy.
\end{conceptbox}

\vspace{0.5cm}

% Diagrama TikZ: memoria dispersa vs contigua
\begin{center}
\begin{tikzpicture}
    % Lista Python
    \node at (0, 1.5) {\textbf{Lista de Python (Dispersa)}};
    \foreach \x in {0, 1.5, 3} {
        \draw[fill=gray!20] (\x,0) rectangle (\x+0.8,0.5);
        \draw[->, thick] (\x+0.4, 0.25) -- (\x+0.4, -0.8);
        \draw[fill=blue!10] (\x+rand*0.5, -1.5) circle (0.3);
    }

    % NumPy Array
    \node at (6, 1.5) {\textbf{Array de NumPy (Contiguo)}};
    \draw[fill=blue!20] (4.5, -0.5) rectangle (7.5, 0.5);
    \node at (5,0) {Dato};
    \node at (6,0) {Dato};
    \node at (7,0) {Dato};
    \node[align=center] at (6, -1.5) {Bloque C/C++\\Optimizado (SIMD)};
\end{tikzpicture}
\end{center}

\subsection{Operaciones vectorizadas: sin bucles}
Todas las operaciones en NumPy se aplican a todo el array a la vez.

\begin{lstlisting}[language=Python, caption={Procesamiento de im√°genes satelitales (simulado)}]
import numpy as np

# Matriz 100x100: humedad del suelo en una finca
humedad = np.random.rand(100, 100)

# Zonas con riesgo de sequ√≠a (humedad < 0.3)
sequia = humedad < 0.3

# Contar celdas en sequ√≠a
area_sequia = np.sum(sequia)
print(f"Area en sequia: {area_sequia} m2")
\end{lstlisting}

\subsection{L√≥gica condicional vectorizada: \texttt{np.where}}
Para tomar decisiones complejas sobre una matriz:

\begin{lstlisting}[language=Python, caption={Presupuesto h√≠drico autom√°tico}]
agua_necesaria = np.where(humedad < 0.4, (0.5 - humedad), 0)
print(f"Agua necesaria: {np.sum(agua_necesaria):.2f}")
\end{lstlisting}

\section*{Reto Final: Sistema de Alerta para Cultivos}

Crea un script \texttt{alerta\_cultivo.py} que defina 3 zonas y eval√∫e sequ√≠a.

\begin{lstlisting}[language=Python, basicstyle=\ttfamily\footnotesize]
zonas = [
    {"nombre": "Norte", "humedad": 35},
    {"nombre": "Sur", "humedad": 60},
    {"nombre": "Este", "humedad": 28}
]

def alerta_sequia(humedad):
    return "RIESGO" if humedad < 40 else "OK"

for z in zonas:
    print(f"{z['nombre']}: {alerta_sequia(z['humedad'])}")
\end{lstlisting}

\end{document}